C343/Summer 2016
Homework 07 Task A
Bryan Brussee
bbrussee

In our group is:
Myself
Jena Hanes (jrhanes)
Daniel Nelson (dajanels)
James Sowinski (japasowi)

Textbook Exercise 9.10

def E transpose(E[] mylist, E searchValue) {
wheneve mylist is acessed {
for (int i = 0; i < mylist.length(); i++) {
	if (mylist[i] == searchvalue) {
	swapvalue = myarray[i - 1];
	accessed = mylist[i];
	myarray[i-1] = accessed;
	myarray[i] = swapvalue; 
	return accessed;
	} 
	mylist.add(searchValue);
    }
}

Textbook Exercise 9.13

a) This is not a hash function, as it will not map every k to an n
within the hashtable - negative numbers will be assigned negative slots, 
which don't exist. So, h(k) does not map every k to a slot. 

b) This is a hash function, but seeing as it maps every k to the same slot,
it is an awful hash function.

c) This is a hash function. Ideally, n would be a large number. If it's too
small, the wrap-around from the modulo will return the same value often,
and with so many collisions, this won't be a very efficient system.

d) This also appears to be a hash function, but it depends on the size of n
relative to the size of k. With n being a prime number, it's equally likely
to spit out any value less than itself and greater than 0. So if K is large,
it shouldn't create a ton of collisions.

Textbook Exercise 9.14

[_, _, 9, 3, 2, 12, _,]

^^^That's what the hash table should look like post-hash.

Here's the odds:

[1/7, 1/7, 9, 3, 2, 12, 5/7]
